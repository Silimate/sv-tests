#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 The SymbiFlow Authors.
#
# Use of this source code is governed by a ISC-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/ISC
#
# SPDX-License-Identifier: ISC
"""
Generator script for Verismith tests.
This script invokes the verismith generation process and wraps the resulting
Verilog files for sv-tests.
"""

import os
import shutil
import subprocess
import sys


def main():
    try:
        third_party_dir = os.environ["THIRD_PARTY_DIR"]
        tests_dir = os.environ["TESTS_DIR"]
    except KeyError:
        print(
            "Error: TESTS_DIR and THIRD_PARTY_DIR environment variables must be set"
        )
        sys.exit(1)

    verismith_dir = os.path.join(third_party_dir, "tests", "verismith")
    if not os.path.isdir(verismith_dir):
        print(f"Error: Verismith directory not found at {verismith_dir}")
        sys.exit(1)

    output_dir = os.path.join(tests_dir, "generated", "verismith")
    os.makedirs(output_dir, exist_ok=True)

    print(f"Generating Verismith samples in {output_dir}")

    # Try to find verismith executable
    verismith_bin = os.environ.get("VERISMITH_BIN")
    use_cabal = False

    if not verismith_bin:
        # Check for pre-built binary in known location
        # This path depends on the architecture/OS/GHC version, so we glob for it
        # Pattern: dist-newstyle/build/**/x/verismith/build/verismith/verismith
        import glob
        pattern = os.path.join(
            verismith_dir, "dist-newstyle", "build", "**", "x", "verismith",
            "build", "verismith", "verismith")
        candidates = glob.glob(pattern, recursive=True)
        if candidates:
            verismith_bin = os.path.abspath(candidates[0])
            print(f"Found pre-built verismith binary: {verismith_bin}")

    if verismith_bin:
        if not os.path.isfile(verismith_bin) or not os.access(verismith_bin,
                                                              os.X_OK):
            print(
                f"Error: VERISMITH_BIN is set to {verismith_bin} but it is not executable."
            )
            sys.exit(1)
    else:
        # Check for cabal
        if shutil.which("cabal"):
            use_cabal = True
        else:
            print(
                "Error: 'cabal' not found in PATH and VERISMITH_BIN not set.")
            print(
                "Please install cabal to build Verismith or set VERISMITH_BIN to a pre-built binary."
            )
            # We exit with 0 to avoid breaking bulk generation, but print error
            # Actually, failing is better so the user knows.
            sys.exit(1)

    num_tests = 5
    for i in range(num_tests):
        test_name = f"verismith_{i}"
        filename = f"{test_name}.v"
        filepath = os.path.abspath(os.path.join(output_dir, filename))

        # Generate the Verilog file
        try:
            if use_cabal:
                cmd = [
                    "cabal", "run", "verismith", "--", "generate", "-o",
                    filepath
                ]
            else:
                cmd = [verismith_bin, "generate", "-o", filepath]

            subprocess.check_call(
                cmd,
                cwd=verismith_dir,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError as e:
            print(f"Error generating {filename}: {e}")
            continue

        # Add sv-tests wrapper metadata to the beginning of the file
        if not os.path.exists(filepath):
            print(f"Warning: {filepath} was not created.")
            continue

        with open(filepath, "r") as f:
            content = f.read()

        # Simple verification tag
        header = f"""/*
:name: {test_name}
:description: Verismith generated test {i}
:tags: verismith
:type: simulation elaboration parsing
*/
"""
        with open(filepath, "w") as f:
            f.write(header + content)

    print(f"Successfully generated {num_tests} tests in {output_dir}")


if __name__ == "__main__":
    main()
